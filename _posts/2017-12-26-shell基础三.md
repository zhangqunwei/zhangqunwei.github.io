---
layout: post
title: shell基础三
date: 2017-12-26
tags: 脚本
---
## bash变量

### 什么是变量
变量是计算机内存单元，其中存放的值可以改变。当shell脚本需要保存一些信息时，
如一个文件名或是一个数字，就把它存放在一个变量中。每一个变量都有一个名字，
所以很容易引用它。使用变量可以保存有用信息，使系统获知用户相关设置，变量也
可以用于保存暂时信息。  

### 变量设置规则  
* 变量名称可以有字母，数字和下划线组成，但是不能以数字开头。  
* 在bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。      
* 变量用等号连接值，等号左右两侧不能有空格。  
* 变量的值如果有空格，需要使用单引号或双引号包括。  
* 在变量的值中，可以使用“\”转义符。
* 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含。        
* 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令    
* 环境变量名建议大写，便于区分。   

### 变量分类
* 用户自定义变量
* 环境变量：这种变量中主要保存的是和系统操作环境相关的数据
* 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的                                                                
* 预定义变量：是bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的   
注：位置参数变量实质上是预定义变量的一种，只是位置参数变量相对较多，我们习惯性的把它拿出来单独作为一个分类

### 本地变量（也叫用户自定义变量）
* 变量定义  
    name="Test"   
* 变量叠加  
    aa=123   
    aa="$aa"456   
    aa=${aa}789   
* 变量调用  
    echo $name   
* 变量查看  
    set   
* 变量删除  
    unset name
                      
### 环境变量

**环境变量是什么**    
    用户自定义变量只在当前shell中生效，而环境变量会在当前shell和这个shell的所有
    子shell中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有
    的shell中生效

**设置环境变量**       
* 声明变量 `export 变量名=变量值` （export的意思是把这个变量声明成全局变量）       
* 查询变量 `env`                
* 删除变量 `unset 变量名`    

注：以上讲的是用户自定义的环境变量，但环境变量用得更多的地方是系统自带的环境变量，也就是用env看到的环境变量
    

**系统常见环境变量**      
* PATH: 系统查找命令的路径   
```bash  
# echo $PATH 
/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/.....  
```   
注：     
1. 在linux中，可执行文件不管是系统的还是自己写的要想运行都必须用路径，可以是绝对路径    
    也可以是相对路径，当我们敲入命令时，系统从PATH中搜索命令所在的路径.      
2. 其实tab键的补全也是在靠PATH的搜索路径.       
    所以综合以上两点我们可以得到： 
        当我们把自己写的脚本路径加到PATH中，再次运行我们的脚本时可以不用加路径，让系统从
        PATH中搜素，而且我们还可以用tab键来补全.      
3. 我们并不习惯把我们自己写的脚本直接拷贝到系统目录当中，这样容易与系统中的内容混淆
        把我们自己搞晕，我们更习惯的是用变量叠加的方式将自己的脚本加到PATH 后边.    
```bash
# PATH="$PATH":/root/sh        PATH变量叠加
```     
注意:这种叠加只是临时的，一旦重启就会消失，永久生效就必须写入相应的配置文件中  

* PS1:定义系统提示符的变量   
    严格来说PS1并不是环境变量，用env是看不到PS1的，只能用set查看，它是系统预留专门用
    于定义系统操作环境的变量，它是环境变量中的一个自分支，只是用env看不到.
```C
\d:   显示日期，格式为“星期  月  日”
\b:   显示简写主机名，如默认主机名“localhost”
\t:   显示24小时制时间，格式为“HH:MM:SS”
\T:   显示12小时制时间，格式为“HH:MM:SS”
\A:   显示24小时制时间，格式为“HH:MM”
\u:   显示当前用户名
\w:   显示当前所在目录的完整名称
\W:   显示当前所在目录的最后一个目录
\#:   执行的第几条命令
\S:   提示符。如果是root用户会显示提示符为#,如果是普通用户会显示$
```
例如：
```bash
PS1="[\u@\t\w]\$"
PS1="[\u@\@ \h\#\W]\$"
PS1="[\u@\h\W]\$"
```
注意：系统默认的环境变量都是大写

---------------------------------
总结:   
* 环境变量和本地变量的区别：   
    环境变量和本地变量的区别是它们的作用范围不同最主要的区别是环境变量对一个系列的shell生效，
    本地变量只对当前shell生效.    
* 环境变量允许用户自由定义，但是最重要的是系统默认的环境变量，一个是PATH一个是PS1.   

---------------------------------

### 位置参数变量  

|位置参数变量    |   作用 |
|:-:            |:-:|
|    $n         |   n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}|
|    $*         |   这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体|
|    $@         |   这个变量也代表命令行中所有的参数，不过$@把每个参数区别对待|
|    $#         |   这个变量代表命令行中所有参数的个数|

注意：位置参数变量是固定的，它的变量的变量名是固定的，它的作用也是固定的，我们能做的就是传入不同的值

例子1:新建canshu1.sh,内容如下
```
#!/bin/bash  
echo $0      
echo $1      
echo $2      
echo $3 
```     
运行：
```bash
# ./canshu1.sh
./canshu1.sh
#./canshu1.sh 11 22 33
./canshu1.sh
11
22
33
```

例子2：新建canshu2.sh,内容如下
```
#!/bin/bash
sum=$(($1+$2))
echo "$1加$2=$sum"
```

例子3：$*与$@ 的区别
```
#!/bin/bash
for i in "$*"
do
    echo "The parameters is: $i"
done
x=1
for y in "$@"
do 
    echo "The parameter$x is:$y"
    x=$(($x+1))
done
```  
注：位置参数变量是预定义变量中的一种，因为其内容较多，所以单独提出讲解  
### 预定义变量
系统事先规定好的，变量名不能更改，变量的作用不能更改。我们只能传入不同的值    

* 预定义变量及作用        

| 预定义变量     |               作用|
|:------:          |:-:| 
|   $?            | 最后一次执行的命令的返回状态。<br>如果这个变量的值为0，证明上一个命令正确执行;<br>如果这个变量的值为非零（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确。<br>（该变量最常用，思考与&& ,\| \| 的联系）|
|   $$            | 当前进程的进程号(PID)|
|   $!            | 后台运行的最后一个进程的进程号（PID）|

例子：新建variable.sh,内容如下
```
#!/bin/bash

#输出当前进程的PID
#这个PID 就是variable.sh这个脚本执行时，生成的进程的PID
echo "The current process is $$"

#使用find命令在root目录下查找hello.sh文件
#符号&的意思是把命令放入后台执行
find /root -name hello.sh &   
echo "The last one Daemon process is $!"
```  

* 接收键盘输入
    read [选项][变量名]   
    选项：  
    -p  "提示信息"　　　在等带read输入时，输出提示信息   
    -t   秒数　　　　　　read命令会一直等待用户输入，使用此选项可以指定等待时间   
    -n  字符数　　　　　read命令只接受指定的字符数，就会执行   
    -s　　　　　　　　隐藏输入的数据，适用于机密信息的输入  

例子：  
```
#!/bin/bash
#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中
read -t 30 -p "Pleasee input your name:" name
echo "Name is $name"

#年龄是隐私，所以我们用 -s 选项隐藏输入
read -s -t 30 -p "Please enter your age: " age
echo -e "\n"
echo "Age is $age"  

#使用 -n 1 选项只接收一个输入字符就会执行（都不用输入回车）
read -n 1 -t 20 -p "Please select your gender[M/F]:" gender
echo -e "\n"
echo "Sex is $gender"
```
## bash的运算符

### 数值运算与运算符
* declare声明变量类型
    格式： declare [+/-][选项] 变量名   
    选项：  
    -:　　给变量设定类型属性  
    +:　　取消变量的类型属性   
    -i:　　将变量声明为整数型（integer）  
    -x:　　将变量声明为环境变量   
    -p:　　显示指定变量的被声明的类型  
* 数值运算  
    * 方法1:    
        aa=11  
        bb=22  
        declare -i cc=$aa+$bb  (将变量cc强制声明成整数型)  
    * 方法2：expr或let数值运算工具    
        aa=11  
        bb=22  
        dd=$(expr $aa + $bb)  
        "+"号左右两侧必须有空格  
* "$((运算符))"或"$[运算符]"  
    aa=11  
    bb=22  
    ff=$(($aa+$bb))  
    gg=$[$aa+$bb]  
    
    
|优先级   | 运算符               | 说明   |
|:-:       | :-:                     |:-:|    
| 13 |     \，+                     |    单目负，单目正 | 
| 12 |     ！，`                    |    逻辑非，按位取反或补码 |
| 11 |     *，/，%                  |    乘，除，取模 |
| 10 |      +，-                    |    加，减 |
| 9  |     <<，>>                   |    按位左移，按位右移 |
| 8  |     <=，>=，<，>              |    小于或等于，大于或等于，小于，大于 |
| 7  |     ==，!=                   |    等于，不等于 |
| 6  |      &                       |    按位与 |
| 5  |      ^                       |    按位异或 |
| 4  |      \|                      |    按位或 |
| 3  |      &&                      |    逻辑与 |
| 2  |      \| \|                   |    逻辑或 |
| 1  |     =，+=，-=，*=，<<=，>>=   |    赋值，运算且赋值 |

### 变量测试与内容替换

|变量置换方式  | 变量y没有设置                     | 变量y为空值           | 变量y设置值  |
|:-:           |:-:                               |:-:                   |:-:         |                                      
|x=${y-新值}    | x=新值                          | x为空                 | x=$y      |
|x=${y:-新值}   | x=新值                          | x=新值                | x=$y      |
|x=${y+新值}    | x为空                           | x=新值                | x=新值    |
|x=${y:+新值}   | x为空                           | x为空                 | x=新值    |
|x=${y=新值}    | x=新值，y=新值                   | x为空，y值不变         | x=$y ,y值不变 |
|x=${y:=新值}   | x=新值，y=新值                   | x=新值，y=新值         | x=$y ,y值不变 |      
|x=${y?新值}    | 新值输出到标准错误输出（屏幕）      | x为空                 | x=$y     | 
|x=${y:?新值}   | 新值输出到标准错误输出             | 新值输出到标准错误输出  | x=$y     |
                                                                      
例子：测试x=${y-新值}
```
[root@localhost ~]# unset y
[root@localhost ~]# x=${y-新值}
[root@localhost ~]# echo $x
new
因为变量y不存在，所以x=new[root@localhost ~]# unset y
[root@localhost ~]# x=${y-新值}
[root@localhost ~]# echo $x
new
因为变量y不存在，所以x=new
```     
        
        